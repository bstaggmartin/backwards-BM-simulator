simBM<-function(tree,x,n.sim=1000,along.branch=T,res=0.01,return.MLE=T,
                lb=-Inf,ub=Inf,lb.reflective=F,ub.reflective=F){
  ##EXTRACTING USEFUL PARAMETERS##
  tree<-ape::reorder.phylo(tree)
  ntax<-length(tree$tip.label)
  edges<-tree$edge
  edge.lens<-tree$edge.length
  tip.states<-x[tree$tip.label];names(tip.states)<-1:ntax
  sigma<-mean(ape::pic(x[1:ntax],phy=tree)^2)
  if(!lb.reflective){
    lb.trunc<-lb
  }else{
    lb.trunc<- -Inf
  }
  if(!ub.reflective){
    ub.trunc<-ub
  }else{
    ub.trunc<-Inf
  }
  ####
  
  ##TIPs-TO-ROOT TREE TRAVERSAL##
  mu<-rep(NA,nrow(edges)+1)
  p<-rep(NA,nrow(edges)+1)
  for(e in nrow(edges):0){
    if(e==0){
      n<-ntax+1
      d<-edges[which(edges[,1]==n),2]
      p.a<-sum(p[d])
      mu[n]<-sum(mu[d]*p[d]/p.a)
      t<-0
      p[n]<-p.a/(1+t*p.a)
      break
    }
    n<-edges[e,2]
    if(length(which(edges[,1]==n))==0){
      mu[n]<-tip.states[n]
      t<-edge.lens[e]
      p[n]<-1/t
    }
    if(length(which(edges[,1]==n))>0){
      d<-edges[which(edges[,1]==n),2]
      p.a<-sum(p[d])
      mu[n]<-sum(mu[d]*p[d]/p.a)
      t<-edge.lens[e]
      p[n]<-p.a/(1+t*p.a)
    }
  }
  ####
  
  ##ROOT-TO-TIPS TREE TRAVERSAL WITH NOISE##
  mu.sim<-matrix(NA,nrow=nrow(edges)+1,ncol=n.sim)
  mu.sim[1:ntax,]<-rep(mu[1:ntax],n.sim)
  mu.sim[ntax+1,]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu[ntax+1],sigma*1/p[ntax+1])
  p.sim<-(p[edges[,2]]/(1-edge.lens*p[edges[,2]])+1/edge.lens)[order(edges[,2])]
  p.sim<-append(p.sim,p[ntax+1],ntax)
  ###reflective bounds calculations
  if(lb.reflective&!(ub.reflective)){
    while(!(all(mu.sim[ntax+1,]>lb))){
      mu.sim[ntax+1,]<-ifelse(mu.sim[ntax+1,]<lb,lb-(mu.sim[ntax+1,]-lb),mu.sim[ntax+1,])
      if(!(all(mu.sim[ntax+1,]<ub))){
        problem.indices<-which(mu.sim[ntax+1,]>ub)
        mu.tmp[ntax+1,problem.indices]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu[ntax+1],sigma*1/p[ntax+1])
      }
    }
  }
  if(ub.reflective&!(lb.reflective)){
    while(!(all(mu.sim[ntax+1,]<ub))){
      mu.sim[ntax+1,]<-ifelse(mu.sim[ntax+1,]>ub,ub-(mu.sim[ntax+1,]-ub),mu.sim[ntax+1,])
      if(!(all(mu.sim[ntax+1,]>lb))){
        problem.indices<-which(mu.sim[ntax+1,]<lb)
        mu.sim[ntax+1,problem.indices]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu[ntax+1],sigma*1/p[ntax+1])
      }
    }
  }
  if(lb.reflective&ub.reflective){
    while(!(all(mu.sim[ntax+1,]>lb&mu.sim[ntax+1,]<ub))){
      mu.sim[ntax+1,]<-ifelse(mu.sim[ntax+1,]<lb,lb-(mu.sim[ntax+1,]-lb),mu.sim[ntax+1,])
      mu.sim[ntax+1,]<-ifelse(mu.sim[ntax+1,]>ub,ub-(mu.sim[ntax+1,]-ub),mu.sim[ntax+1,])
    }
  }
  ###
  for(e in 1:nrow(edges)){
    n<-edges[e,2]
    if(length(which(edges[,1]==n))==0){
      next
    }
    a.n<-edges[e,1]
    t<-edge.lens[e]
    mu.sim[n,]<-mu[n]*p[n]*t+mu.sim[a.n,]-mu.sim[a.n,]*p[n]*t
    mu.sim[n,]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu.sim[n,],sigma*1/p.sim[n])
    ###reflective bounds calculations
    if(lb.reflective&!(ub.reflective)){
      while(!(all(mu.sim[n,]>lb))){
        mu.sim[ntax+1,]<-ifelse(mu.sim[n,]<lb,lb-(mu.sim[n,]-lb),mu.sim[n,])
        if(!(all(mu.sim[n,]<ub))){
          problem.indices<-which(mu.sim[n,]>ub)
          mu.tmp[n,problem.indices]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu.sim[n,],sigma*1/p.sim[n])
        }
      }
    }
    if(ub.reflective&!(lb.reflective)){
      while(!(all(mu.sim[n,]<ub))){
        mu.sim[ntax+1,]<-ifelse(mu.sim[n,]>ub,ub-(mu.sim[n,]-ub),mu.sim[n,])
        if(!(all(mu.sim[n,]>lb))){
          problem.indices<-which(mu.sim[n,]<lb)
          mu.sim[n,problem.indices]<-truncnorm::rtruncnorm(n.sim,lb.trunc,ub.trunc,mu.sim[n,],sigma*1/p.sim[n])
        }
      }
    }
    if(lb.reflective&ub.reflective){
      while(!(all(mu.sim[n,]>lb&mu.sim[n,]<ub))){
        mu.sim[n,]<-ifelse(mu.sim[n,]<lb,lb-(mu.sim[n,]-lb),mu.sim[n,])
        mu.sim[n,]<-ifelse(mu.sim[n,]>ub,ub-(mu.sim[n,]-ub),mu.sim[n,])
      }
    }
    ###
  }
  ####
  
  ##SIMULATING ANAGENETIC CHANGE ALONG BRANCHES##
  if(along.branch){
    time.vec<-seq(0,max(node.depth.edgelength(tree)),length.out=1/res)
    get.last.pt<-function(ii,tt,tts){
      max(which(!is.na(ii)&tts<tt))
    }
    get.next.pt<-function(ii,tt,tts){
      min(which(!is.na(ii)&tts>tt))
    }
    interp<-function(sims,mus,time.pts,time.pt,sig,int.lb.trunc=lb.trunc,int.ub.trunc=ub.trunc){
      mus<-as.matrix(mus)
      last.pt<-mapply(get.last.pt,
                      ii=split(mus,rep(1:sims,each=nrow(mus))),
                      tt=split(time.pts[time.pt],1:length(time.pt)),
                      tts=rep(list(time.pts),sims))
      next.pt<-mapply(get.next.pt,
                      ii=split(mus,rep(1:sims,each=nrow(mus))),
                      tt=split(time.pts[time.pt],1:length(time.pt)),
                      tts=rep(list(time.pts),sims))
      truncnorm::rtruncnorm(sims,int.lb.trunc,int.ub.trunc,
                            (time.pts[time.pt]-time.pts[last.pt])/(time.pts[next.pt]-time.pts[last.pt])*
                              (mus[cbind(next.pt,1:sims)]-mus[cbind(last.pt,1:sims)])+mus[cbind(last.pt,1:sims)],
                            sig*(time.pts[time.pt]-time.pts[last.pt])*
                              (time.pts[next.pt]-time.pts[time.pt])/
                              (time.pts[next.pt]-time.pts[last.pt]))
    }
    mu.mat<-array(NA,dim=c(nrow(edges),length(time.vec),n.sim))
    for(e in 1:nrow(edges)){
      n1<-edges[e,1];n2<-edges[e,2]
      t1<-node.depth.edgelength(tree)[n1];t2<-node.depth.edgelength(tree)[n2]
      int.ts<-which(time.vec>t1&time.vec<t2)
      if(length(int.ts>0)){
        start.mus<-mu.sim[n1,];end.mus<-mu.sim[n2,]
        mu.tmp<-rbind(start.mus,mu.mat[e,int.ts,],end.mus)
        t.tmp<-c(t1,time.vec[int.ts],t2)
        ###special case when there is only 1 intervening time point between two nodes
        if(length(int.ts)==1){
          mu.tmp[2,]<-interp(sims=n.sim,mus=mu.tmp,time.pts=t.tmp,time.pt=rep(2,n.sim),sig=sigma)
          ###reflective bounds calculations
          if(lb.reflective&!(ub.reflective)){
            while(!(all(mu.tmp[2,]>lb))){
              mu.tmp[2,]<-ifelse(mu.tmp[2,]<lb,lb-(mu.tmp[2,]-lb),mu.tmp[2,])
              if(!(all(mu.tmp[2,]<ub))){
                problem.indices<-which(mu.tmp[2,]>ub)
                mu.tmp[2,problem.indices]<-interp(sims=length(problem.indices),mus=mu.tmp[,problem.indices],
                                                  time.pts=t.tmp,time.pt=2,sig=sigma)
              }
            }
          }
          if(ub.reflective&!(lb.reflective)){
            while(!(all(mu.tmp[2,]<ub))){
              mu.tmp[2,]<-ifelse(mu.tmp[2,]>ub,ub-(mu.tmp[2,]-ub),mu.tmp[2,])
              if(!(all(mu.tmp[2,]>lb))){
                problem.indices<-which(mu.tmp[2,]<lb)
                mu.tmp[2,problem.indices]<-interp(sims=length(problem.indices),mus=mu.tmp[,problem.indices],
                                                  time.pts=t.tmp,time.pt=2,sig=sigma)
              }
            }
          }
          if(lb.reflective&ub.reflective){
            while(!(all(mu.tmp[2,]>lb&mu.tmp[2,]<ub))){
              mu.tmp[2,]<-ifelse(mu.tmp[2,]<lb,lb-(mu.tmp[2,]-lb),mu.tmp[2,])
              mu.tmp[2,]<-ifelse(mu.tmp[2,]>ub,ub-(mu.tmp[2,]-ub),mu.tmp[2,])
            }
          }
          ###
        ###normal case
        }else{
          ord.tmp<-sapply(1:n.sim,function(ii) sample(x=2:(length(t.tmp)-1),size=length(t.tmp)-2))
          for(i in 1:nrow(ord.tmp)){
            tmp.indices<-cbind(ord.tmp[i,],1:n.sim)
            mu.tmp[tmp.indices]<-interp(sims=n.sim,mus=mu.tmp,time.pts=t.tmp,time.pt=ord.tmp[i,],sig=sigma)
            ###reflective bounds calculations
            if(lb.reflective&!(ub.reflective)){
              while(!(all(mu.tmp[tmp.indices]>lb))){
                mu.tmp[tmp.indices]<-ifelse(mu.tmp[tmp.indices]<lb,
                                            lb-(mu.tmp[tmp.indices]-lb),
                                            mu.tmp[tmp.indices])
                if(!(all(mu.tmp[tmp.indices]<ub))){
                  problem.indices<-which(mu.tmp[tmp.indices]>ub)
                  mu.tmp[tmp.indices[problem.indices,]]<-interp(sims=length(problem.indices),
                                                                mus=mu.tmp[,problem.indices],
                                                                time.pts=t.tmp,
                                                                time.pt=ord.tmp[i,problem.indices],
                                                                sig=sigma)
                }
              }
            }
            if(ub.reflective&!(lb.reflective)){
              while(!(all(mu.tmp[tmp.indices]<ub))){
                mu.tmp[tmp.indices]<-ifelse(mu.tmp[tmp.indices]>ub,
                                            ub-(mu.tmp[tmp.indices]-ub),
                                            mu.tmp[tmp.indices])
                if(!(all(mu.tmp[tmp.indices]>lb))){
                  problem.indices<-which(mu.tmp[tmp.indices]<lb)
                  mu.tmp[tmp.indices[problem.indices,]]<-interp(sims=length(problem.indices),
                                                                mus=mu.tmp[,problem.indices],
                                                                time.pts=t.tmp,
                                                                time.pt=ord.tmp[i,problem.indices],
                                                                sig=sigma)
                }
              }
            }
            if(lb.reflective&ub.reflective){
              while(!(all(mu.tmp[tmp.indices]>lb&mu.tmp[tmp.indices]<ub))){
                mu.tmp[tmp.indices]<-ifelse(mu.tmp[tmp.indices]<lb,
                                            lb-(mu.tmp[tmp.indices]-lb),
                                            mu.tmp[tmp.indices])
                mu.tmp[tmp.indices]<-ifelse(mu.tmp[tmp.indices]>ub,
                                            ub-(mu.tmp[tmp.indices]-ub),
                                            mu.tmp[tmp.indices])
              }
            }
            ###
          }
        }
        mu.tmp<-mu.tmp[-c(1,nrow(mu.tmp)),]
        mu.mat[e,int.ts,]<-mu.tmp
      }
    }
  }
  ####
  
  ##ROOT-TO-TIPS TREE TRAVERSAL TO GET OVERALL ML ESTIMATES##
  if(return.MLE){
    mu.true<-mu
    p.true<-p
    for(e in 1:nrow(edges)){
      n<-edges[e,2]
      if(length(which(edges[,1]==n))==0){
        next
      }
      a.n<-edges[e,1]
      t<-edge.lens[e]
      mu.true[n]<-mu.true[n]*p.true[n]*t+mu.true[a.n]-mu.true[a.n]*p.true[n]*t
      p.true[n]<-p.true[n]/(1-t*p.true[n])+(p.true[a.n]-p.true[n])/(1+t*(p.true[a.n]-p.true[n]))
    }
  }
  ####
  
  ##OUTPUT##
  if(!return.MLE&!along.branch){
    out<-list(nodes=mu.sim)
  }else if(return.MLE&!along.branch){
    out<-list(nodes=mu.sim,MLE=mu.true,MLE.se=c(rep(0,ntax),sigma*1/p.true[ntax+(1:tree$Nnode)]))
  }else if(!return.MLE&along.branch){
    out<-list(nodes=mu.sim,edges=mu.mat,ts=time.vec)
  }else{
    out<-list(nodes=mu.sim,edges=mu.mat,ts=time.vec,MLE=mu.true,MLE.se=c(rep(0,ntax),sigma*1/p.true[ntax+(1:tree$Nnode)]))
  }
  class(out)<-"simBM"
  out
}
