#plot an autocorrelated Brownian motion simulation
#' @export
plot.corateBM<-function(sim,tree,trait=1:NCOL(sim$X),
                        lwd=1,col=c('deepskyblue','darkgray','brown1'),alpha=NA,
                        phenogram=T,val.range=if(is.null(sim$R)) c(0,0) else range(sim$R),res=100,
                        xlab=NULL,ylab=NULL,add=F,...){
  if(!is.character(trait)&!is.numeric(trait)){
    stop('trait must be a numeric or character vector')
  }
  if(is.null(xlab)){
    if(length(trait)==1){
      xlab<-'time'
    }else{
      xlab<-ifelse(is.numeric(trait),paste('trait',trait[1]),trait[1])
    }
  }
  if(is.null(ylab)){
    if(is.character(trait)){
      if(length(trait)==1){
        ylab<-trait
      }else{
        ylab<-trait[2]
      }
    }else if(is.numeric(trait)){
      if(length(trait)==1){
        ylab<-paste('trait',trait)
      }else{
        ylab<-paste('trait',trait[2])
      }
    }
  }
  if(any(names(list(...))=='edge.width')){
    warning('plot.corateBM uses lwd rather than edge.width to control line width: edge.width was ignored')
  }
  if(is.character(trait)){
    new.trait<-match(trait,colnames(sim$X))
    problem.index<-which(is.na(new.trait))
    if(length(problem.index)>0){
      stop("can't find trait(s) matching with ",paste(trait[problem.index],collapse=', '))
    }else{
      trait<-new.trait
    }
  }
  if(any(trait>ncol(sim$X))){
    problem.index<-which(trait>ncol(sim$X))
    stop("can't find trait(s) matching with ",paste(trait[problem.index],collapse=', '))
  }
  if(length(trait)>2&!phenogram){
    pairs(sim,tree,trait=trait,lwd=lwd,col=col,alpha=alpha,val.range=val.range,res=res,...)
  }else{
    colramp<-colorRampPalette(col)(res)
    if((val.range[2]-val.range[1])==0){
      colvec<-colramp[round((res+1)/2)]
    }else{
      inds<-round((sim$R-val.range[1])/(val.range[2]-val.range[1])*(res-1))+1
      inds[inds<1]<-1;inds[inds>res]<-res
      colvec<-colramp[inds]
    }
    colvec<-alter.cols(colvec,alpha=alpha)
    if(phenogram){
      n<-length(tree$tip.label)
      if(nrow(sim$X)==n){
        scaled.tree<-tree
        if(!is.null(sim$R)){
          scaled.tree$edge.length<-tree$edge.length*exp(sim$R)
        }
        anc.states<-matrix(NA,tree$Nnode,ncol(sim$X))
        rownames(anc.states)<-n+1:tree$Nnode
        for(i in trait){
          anc.states[,i]<-.quick.recon(sim$X[,i],scaled.tree)
        }
        sim$X<-rbind(sim$X,anc.states)
      }
      sim$X<-as.matrix(sim$X[c(tree$tip.label,n+1:tree$Nnode),])
      if(length(trait)==1){
        if(hasArg(node.depths)){
          xx<-list(...)$node.depths
        }else{
          xx<-node.depth.edgelength(tree)
        }
        if(!add){
          do.call(plot,
                  c(x=list(xx),
                    y=list(sim$X[,trait]),
                    xlab=xlab,
                    ylab=ylab,
                    col='white',
                    type='p',
                    pch=1,
                    list(...)[!(names(list(...))%in%c('type','pch','edge.width','node.depths'))]))
        }
        do.call(segments,
                c(x0=list(xx[tree$edge[,1]]),x1=list(xx[tree$edge[,2]]),
                  y0=list(sim$X[,trait][tree$edge[,1]]),y1=list(sim$X[,trait][tree$edge[,2]]),
                  lwd=ifelse(length(lwd)>1,list(lwd),lwd),
                  col=list(colvec),
                  list(...)[!(names(list(...))%in%c('edge.width','node.depths'))]))
      }else{
        if(!add){
          do.call(plot,
                  c(x=list(sim$X[,trait[1]]),
                    y=list(sim$X[,trait[2]]),
                    xlab=xlab,
                    ylab=ylab,
                    col='white',
                    type='p',
                    pch=1,
                    list(...)[!(names(list(...))%in%c('type','pch','edge.width','node.depths'))]))
        }
        do.call(segments,
                c(x0=list(sim$X[,trait[1]][tree$edge[,1]]),x1=list(sim$X[,trait[1]][tree$edge[,2]]),
                  y0=list(sim$X[,trait[2]][tree$edge[,1]]),y1=list(sim$X[,trait[2]][tree$edge[,2]]),
                  lwd=ifelse(length(lwd)>1,list(lwd),lwd),
                  col=list(colvec),
                  list(...)[!(names(list(...))%in%c('edge.width','node.depths'))]))
      }
    }else{
      do.call(plot,
              c(x=list(tree),
                edge.color=list(colvec),
                edge.width=ifelse(length(lwd)>1,list(lwd),lwd),
                list(...)[!(names(list(...))%in%c('edge.color','edge.width'))]))
    }
  }
}

#improve label handling
#' @export
pairs.corateBM<-function(sim,tree,trait=1:ncol(sim$X),lwd=1,col=c('deepskyblue','darkgray','brown1'),alpha=NA,
                         val.range=if(is.null(sim$R)) c(0,0) else range(sim$R),res=100,...){
  n<-length(tree$tip.label)
  if(nrow(sim$X)==n){
    scaled.tree<-tree
    if(!is.null(sim$R)){
      scaled.tree$edge.length<-tree$edge.length*exp(sim$R)
    }
    anc.states<-matrix(NA,tree$Nnode,ncol(sim$X))
    rownames(anc.states)<-n+1:tree$Nnode
    for(i in trait){
      anc.states[,i]<-.quick.recon(sim$X[,i],scaled.tree)
    }
    sim$X<-rbind(sim$X,anc.states)
  }
  sim$X<-as.matrix(sim$X[c(tree$tip.label,n+1:tree$Nnode),])
  old.par<-par(no.readonly=T)
  par(mfrow=c(length(trait),length(trait)),mar=c(0,0,0,0),oma=c(5.1,4.1,0,0),xpd=T)
  for(i in 1:length(trait)){
    for(j in 1:length(trait)){
      if(j==1){
        yaxt=NULL
        args.y.mtext<-list(text=paste('trait',trait[i]),
                           side=2,
                           line=3,
                           cex=0.75)
      }else{
        yaxt='n'
        args.y.mtext<-list(NULL)
      }
      if(i==length(trait)){
        xaxt=NULL
        args.x.mtext<-list(text=paste('trait',trait[j]),
                           side=1,
                           line=3,
                           cex=0.75)
      }else{
        xaxt='n'
        args.x.mtext<-list(NULL)
      }
      if(i==j){
        if(i==length(trait)){
          plot(sim,tree,trait=c(trait[i],trait[j]),alpha=0,
               xaxt=xaxt,yaxt=yaxt,...)
          new.range<-range(sim$X[,i])
          node.depths<-node.depth.edgelength(tree)
          node.depths<-node.depths/max(node.depths)*diff(new.range)+min(new.range)
          plot(sim,tree,trait=i,lwd=lwd,col=col,alpha=alpha,val.range=val.range,res=res,
               xaxt='n',yaxt=yaxt,add=T,node.depths=node.depths,...)
        }else{
          plot(sim,tree,trait=trait[i],lwd=lwd,col=col,alpha=alpha,val.range=val.range,res=res,
               xaxt=xaxt,yaxt=yaxt,...)
        }
        do.call(mtext,args.x.mtext)
        do.call(mtext,args.y.mtext)
      }else{
        plot(sim,tree,trait=c(trait[j],trait[i]),lwd=lwd,col=col,alpha=alpha,val.range=val.range,res=res,
             xaxt=xaxt,yaxt=yaxt,...)
        do.call(mtext,args.x.mtext)
        do.call(mtext,args.y.mtext)
      }
    }
  }
  par(old.par)
}