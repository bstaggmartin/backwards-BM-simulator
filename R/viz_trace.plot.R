#make an argument for where to cap off legend/plot title for a given number of parameters
#extra argument to combine chains, if desired?
#col and lwd apply to diff parameters, lty to diff chains
#p is used to plot horizontal lines representing quantiles (could do  a fade effect with a bit more work--might be interesting
#to consider). set to NULL to plot no lines
#' @export
trace.plot<-function(in.x,p=0.05,col=palette(),
                     lower.quant=NULL,upper.quant=NULL,lower.cut=NULL,upper.cut=NULL,add=F,
                     make.legend=T,...){
  plot.args<-c(names(formals(plot.default)),
               names(formals(axis)),names(formals(box)),names(formals(plot.window)),names(formals(title)))
  plot.args<-plot.args[-which(plot.args=='...')]
  gen.args<-names(par())
  if(hasArg(fit)){
    fit<-list(...)$fit
  }else{
    fit<-NULL
  }
  x<-in.x
  if(!is.list(x)){
    x<-list(x)
  }
  x<-.expand.element(do.call(ele.c,c(x,fit=list(fit))))
  param.names<-names(x) #shouldn't ever be a list since elements were combined...
  tmp<-paste0('%(\\',paste(.Ops.ls(),collapse='|\\'),')%')
  param.names<-gsub(tmp,' \\1 ',param.names)
  if(hasArg(overwrite.param.names)){
    overwrite.param.names<-list(...)$overwrite.param.names
    if(length(overwrite.param.names)==length(param.names)){
      param.names<-overwrite.param.names
    }
  }
  if(!hasArg(xlim)){
    xlim<-c(0,dim(x)[1])
  }else{
    xlim<-list(...)$xlim
  }
  if(!hasArg(ylim)){
    ylim<-range(.strip.ele(x),na.rm=T)
  }else{
    ylim<-list(...)$ylim
  }
  if(!hasArg(xlab)){
    xlab<-'Iteration'
  }else{
    xlab<-list(...)$xlab
  }
  if(!hasArg(ylab)){
    if(length(param.names)>5){
      ylab<-deparse(substitute(in.x))
    }else{
      tmp.nms<-param.names
      modes<-unlist(lapply(tmp.nms,mode))
      not.expr<-modes=='numeric'|modes=='character'
      tmp.nms[not.expr]<-lapply(tmp.nms[not.expr],function(ii) paste0('"',ii,'"'))
      ylab<-str2expression(paste(as.character(tmp.nms),collapse="*'; '*"))
    }
  }else{
    ylab<-list(...)$ylab
  }
  if(!add){
    do.call(plot,
            c(x=list(0),
              col=list('white'),
              xlim=list(xlim),
              ylim=list(ylim),
              xlab=list(xlab),
              ylab=list(ylab),
              list(...)[!(names(list(...))%in%c('x','col','xlim','ylim','xlab','ylab'))&
                          names(list(...))%in%c(plot.args,gen.args)]))
  }
  if(is.null(p)){
    probs<-rep(NA,length.out=length(param.names))
    probs<-cbind(probs,probs)
  }else{
    p<-rep(p,length.out=length(param.names))
    probs<-matrix(c(0,1)+c(1,-1)*rep(p,each=2)/2,length(param.names),2,byrow=T)
  }
  if(!is.null(lower.quant)){
    lower.quant<-rep(lower.quant,length.out=length(param.names))
    probs[!is.na(lower.quant),1]<-lower.quant[!is.na(lower.quant)]
  }
  if(!is.null(upper.quant)){
    upper.quant<-rep(upper.quant,length.out=length(param.names))
    probs[!is.na(upper.quant),2]<-upper.quant[!is.na(upper.quant)]
  }
  cuts<-t(mapply(quantile,x=asplit(x,(1:length(dim(x)))[-1]),probs=asplit(probs,1),na.rm=T))
  if(!is.null(lower.cut)){
    lower.cut<-rep(lower.cut,length.out=length(param.names))
    cuts[!is.na(lower.cut),1]<-lower.cut[!is.na(lower.cut)]
  }
  if(!is.null(upper.cut)){
    upper.cut<-rep(upper.cut,length.out=length(param.names))
    cuts[!is.na(upper.cut),2]<-upper.cut[!is.na(upper.cut)]
  }
  tot.len<-prod(dim(x)[-1])
  nchains<-tot.len/length(param.names)
  cuts<-aperm(array(cuts,c(length(param.names),nchains,2)),c(1,3,2))
  col<-rep(col,length.out=length(param.names))
  if(hasArg(alpha)){
    alpha<-rep(list(...)$alpha,length.out=length(param.names))
    col<-alter.cols(col,alpha=alpha)
  }
  if(!hasArg(lwd)){
    lwd<-1
  }else{
    lwd<-rep(list(...)$lwd,length.out=length(param.names))
  }
  if(nchains>1){
    chain.names<-dimnames(x)[[which(names(dimnames(x))=='chains')]]
    if(!hasArg(lty)){
      lty<-rep(2:5,length.out=nchains)
    }else{
      lty<-rep(list(...)$lty,length.out=nchains)
    }
  }else{
    if(!hasArg(lty)){
      lty<-1
    }else{
      lty<-list(...)$lty[1]
    }
  }
  for(i in 1:nchains){
    do.call(matplot,
            c(x=list(x[,,i]),
              col=list(col),
              lwd=list(lwd),
              lty=list(lty[i]),
              type=list('l'),
              add=list(T),
              list(...)[!(names(list(...))%in%c('x','y','col','lwd','lty','type','add'))&
                          names(list(...))%in%c(gen.args)]))
    do.call(abline,
            c(h=list(cuts[,,i]),
              col=list(col),
              lwd=list(lwd),
              lty=list(lty[i]),
              list(...)[!(names(list(...))%in%c('h','b','col','lwd','lty'))&
                          names(list(...))%in%c(gen.args)]))
  }
  if(make.legend){
    legend.args<-list(...)[names(list(...))%in%paste0('legend.',names(formals(legend)))]
    names(legend.args)<-sub('^legend.','',names(legend.args))
    if(is.null(legend.args$x)){
      legend.args$x<-'topright'
    }
    legend.args$legend<-NULL
    legend.args$col<-NULL
    legend.args$lwd<-NULL
    legend.args$lty<-NULL
    if(length(param.names)>1){
      legend.args$legend<-as.expression(param.names)
      legend.args$col<-col
      legend.args$lwd<-lwd
      legend.args$lty<-rep(lty[1],length(param.names))
    }
    if(nchains>1){
      legend.args$legend<-c(legend.args$legend,chain.names)
      legend.args$col<-c(legend.args$col,rep(col[1],length(chain.names)))
      legend.args$lwd<-c(legend.args$lwd,rep(lwd[1],length(chain.names)))
      legend.args$lty<-c(legend.args$lty,lty)
    }
    if(!is.null(legend.args$legend)){
      do.call(legend,legend.args)
    }
  }
}
