#make an argument for where to cap off legend/plot title for a given number of parameters
#extra argument to combine chains, if desired?
#col and lwd apply to diff parameters, lty to diff chains
#p is used to plot horizontal lines representing quantiles (could do  a fade effect with a bit more work--might be interesting
#to consider). set to NULL to plot no lines
#' @export
trace.plot<-function(in.x,p=0.05,col=palette(),exp=F,sqrt=F,
                     lower.quant=NULL,upper.quant=NULL,lower.cut=NULL,upper.cut=NULL,add=F,
                     make.legend=T,...){
  plot.args<-c(names(formals(plot.default)),
               names(formals(axis)),names(formals(box)),names(formals(plot.window)),names(formals(title)))
  plot.args<-plot.args[-which(plot.args=='...')]
  gen.args<-graphics:::.Pars
  if(hasArg(fit)){
    fit<-list(...)$fit
  }else{
    fit<-NULL
  }
  if(is.list(in.x)|is.character(in.x)|length(in.x)==1){
    x<-.combine.elements(in.x,fit,element='chains',simplify=F)
  }else if(is.numeric(in.x)){
    if(is.vector(in.x)&is.null(attributes(in.x))){
      x<-.int.chains(fit,in.x)
    }else{
      x<-.expand.element(in.x)
    }
  }else{
    stop('Input not recognized.')
  }
  if(sqrt){
    if(any(x<0)){
      warning()
    }
    x<-sqrt(x)
  }
  if(exp){
    x<-exp(x)
  }
  param.names<-dimnames(x)[which(names(dimnames(x))=='parameters')]
  if(length(param.names)>1){
    param.names<-do.call(paste,
                         c(lapply(1:length(param.names),function(ii)
                           rep(rep(param.names[[ii]],prod(lengths(param.names)[(1:length(param.names))[1:length(param.names)>ii]])),
                               each=prod(lengths(param.names)[(1:length(param.names))[1:length(param.names)<ii]]))),
                           sep=','))
  }else{
    param.names<-param.names[[1]]
  }
  param.names<-gsub('%(-|/|\\+|\\*)%',' \\1 ',param.names)
  if(!hasArg(xlim)){
    xlim<-c(0,dim(x)[1])
  }else{
    xlim<-list(...)$xlim
  }
  if(!hasArg(ylim)){
    ylim<-range(x,na.rm=T)
  }else{
    ylim<-list(...)$ylim
  }
  if(!hasArg(xlab)){
    xlab<-'Iteration'
  }else{
    xlab<-list(...)$xlab
  }
  if(!hasArg(ylab)){
    if(length(param.names)>5){
      ylab<-deparse(substitute(in.x))
    }else{
      ylab<-paste(param.names,collapse='; ')
    }
  }else{
    ylab<-list(...)$ylab
  }
  if(!add){
    do.call(plot,
            c(x=list(0),
              col=list('white'),
              xlim=list(xlim),
              ylim=list(ylim),
              xlab=list(xlab),
              ylab=list(ylab),
              list(...)[!(names(list(...))%in%c('x','col','xlim','ylim','xlab','ylab'))&
                          names(list(...))%in%c(plot.args,gen.args)]))
  }
  if(is.null(p)){
    probs<-rep(NA,length.out=length(param.names))
    probs<-cbind(probs,probs)
  }else{
    p<-rep(p,length.out=length(param.names))
    probs<-matrix(c(0,1)+c(1,-1)*rep(p,each=2)/2,length(param.names),2,byrow=T)
  }
  if(!is.null(lower.quant)){
    lower.quant<-rep(lower.quant,length.out=length(param.names))
    probs[!is.na(lower.quant),1]<-lower.quant[!is.na(lower.quant)]
  }
  if(!is.null(upper.quant)){
    upper.quant<-rep(upper.quant,length.out=length(param.names))
    probs[!is.na(upper.quant),2]<-upper.quant[!is.na(upper.quant)]
  }
  cuts<-t(mapply(quantile,x=asplit(x,(1:length(dim(x)))[-1]),probs=asplit(probs,1),na.rm=T))
  if(!is.null(lower.cut)){
    lower.cut<-rep(lower.cut,length.out=length(param.names))
    cuts[!is.na(lower.cut),1]<-lower.cut[!is.na(lower.cut)]
  }
  if(!is.null(upper.cut)){
    upper.cut<-rep(upper.cut,length.out=length(param.names))
    cuts[!is.na(upper.cut),2]<-upper.cut[!is.na(upper.cut)]
  }
  tot.len<-prod(dim(x)[-1])
  nchains<-tot.len/length(param.names)
  cuts<-aperm(array(cuts,c(length(param.names),nchains,2)),c(1,3,2))
  col<-rep(col,length.out=length(param.names))
  if(hasArg(alpha)){
    alpha<-rep(list(...)$alpha,length.out=length(param.names))
    col<-alter.cols(col,alpha=alpha)
  }
  if(!hasArg(lwd)){
    lwd<-1
  }else{
    lwd<-rep(list(...)$lwd,length.out=length(param.names))
  }
  if(nchains>1){
    chain.names<-dimnames(x)[[which(names(dimnames(x))=='chains')]]
    if(!hasArg(lty)){
      lty<-rep(2:5,length.out=nchains)
    }else{
      lty<-rep(list(...)$lty,length.out=nchains)
    }
  }else{
    if(!hasArg(lty)){
      lty<-1
    }else{
      lty<-list(...)$lty[1]
    }
  }
  for(i in 1:nchains){
    do.call(matplot,
            c(x=list(x[,,i]),
              col=list(col),
              lwd=list(lwd),
              lty=list(lty[i]),
              type=list('l'),
              add=list(T),
              list(...)[!(names(list(...))%in%c('x','y','col','lwd','lty','type','add'))&
                          names(list(...))%in%c(gen.args)]))
    do.call(abline,
            c(h=list(cuts[,,i]),
              col=list(col),
              lwd=list(lwd),
              lty=list(lty[i]),
              list(...)[!(names(list(...))%in%c('h','b','col','lwd','lty'))&
                          names(list(...))%in%c(gen.args)]))
  }
  if(make.legend){
    legend.args<-list(...)[names(list(...))%in%paste0('legend.',names(formals(legend)))]
    names(legend.args)<-sub('^legend.','',names(legend.args))
    if(is.null(legend.args$x)){
      legend.args$x<-'topright'
    }
    legend.args$legend<-NULL
    legend.args$col<-NULL
    legend.args$lwd<-NULL
    legend.args$lty<-NULL
    if(length(param.names)>1){
      legend.args$legend<-param.names
      legend.args$col<-col
      legend.args$lwd<-lwd
      legend.args$lty<-rep(lty[1],length(param.names))
    }
    if(nchains>1){
      legend.args$legend<-c(legend.args$legend,chain.names)
      legend.args$col<-c(legend.args$col,rep(col[1],length(chain.names)))
      legend.args$lwd<-c(legend.args$lwd,rep(lwd[1],length(chain.names)))
      legend.args$lty<-c(legend.args$lty,lty)
    }
    if(!is.null(legend.args$legend)){
      do.call(legend,legend.args)
    }
  }
}
