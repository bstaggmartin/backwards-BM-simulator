% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/OUT_GET_get.traits.R
\name{get.post.traits}
\alias{get.post.traits}
\title{Sample posterior trait values at nodes given a fitted evorates model}
\usage{
get.post.traits(
  fit,
  select = seq_len(Ntip(fit) + Nnode(fit)),
  type = c("chains", "quantiles", "means", "diagnostics"),
  extra.select = NULL,
  simplify = TRUE,
  store.in.fit = FALSE,
  force.resample = FALSE
)
}
\arguments{
\item{fit}{An object of class "\code{evorates_fit}".}

\item{select}{A numeric vector specifying node indices in \code{fit$call$tree} for  which
to extract trait values. These can be negative to exclude nodes as well. As with all
objects of class "\code{phylo}", the first \code{n} nodes correspond to tips (where \code{n}
is the number of tips in the tree) and the rest correspond to internal nodes. All nodes (tip
and internal alike) are extracted by default.}

\item{type}{A string specifying whether to extract posterior samples ("\code{chains}"),
quantiles ("\code{quantiles}"), means ("\code{means}"), or diagnostics ("\code{diagnostics}").
Can be any unambiguous abbreviation of these strings as well. Defaults to extracting
posterior samples.}

\item{extra.select}{A numeric, integer, or character vector specifying the specific samples/
quantiles/diagnostics to extract, depending on \code{type}. Defaults to \code{NULL},
which generally extracts all available samples/quantiles/diagnostics. See documentation on
param_block operators for details (\link{grapes-chains-grapes}, \link{grapes-quantiles-grapes},
\link{grapes-means-grapes}, or \link{grapes-diagnostics-grapes}).}

\item{simplify}{\code{TRUE} or \code{FALSE}: should the resulting \code{param_block} array be 
simplified? If \code{TRUE} (the default), dimensions of length 1 in the result are
automatically collapsed, with corresponding information stored as attributes (this is the default
behavior of param_block operators).}

\item{force.resample}{}
}
\value{
An array of class "\code{param_block}" with a \code{param_type} set to whatever
\code{type} is. The dimension of these arrays will generally go in the order of
iterations/quantiles/diagnostics, then parameters, then chains. Any dimensions of length 1 are
collapsed and stored as attributes if \code{simplify} is \code{TRUE}. Parameters go by the
name \code{<trait.name>_i}, where \code{i} is the label or index of the corresponding tip or internal
node, respectively, in \code{fit$call$tree}.

Names of outputted parameters follow the format: "\code{<trait.name>_i}", where i is the corresponding
tip label or internal node index from \code{fit$call$tree}. As of now, the function actually completely
ignores \code{tree$node.label}--I should probably fix that and plan to in the future. The trait name
corresponds to the column name of \code{fit$call$trait.data}, which is "X1" if not provided in the
original input to \code{fit.evorates()} or \code{input.evorates()}.
}
\description{
This function samples trait values at tips or internal nodes (a form of stochastic
ancestral state reconstruction) given an \code{evorates_fit} object.
}
\details{
The tip and node indices of \code{fit$call$tree} can be viewed by running:
\code{plot(fit$call$tree); tiplabels(); nodelabels()}.

Note that this function does random sampling internally, so you will get different results
every time you run it unless you use a consistent seed (e.g., using \code{set.seed()}). Depending
on your goals, it may be simpler and more efficient to initially extract posterior samples for all
nodes and then do any further extractions on the outputted param_block.
}
\examples{
#get whale/dolphin evorates fit
data("cet_fit")

#get posterior samples of all trait values
x <- get.post.traits(cet_fit)
#let's say we want to get some trait values towards the root
plot(cet_fit$call$tree); nodelabels()
#select particular edges
x <- get.post.traits(cet_fit, select = c(89, 90, 94, 103, 104, 105))
#maybe specific samples too?
x <- get.post.traits(cet_fit, select = c(89, 90, 94, 103, 104, 105),
                     extra.select=c(1, 23, 47))

#this may be a more common way to get node indices; say we want to look at the genus Mesoplodon
edges <- get.clade.edges(cet_fit$call$tree, "Mesoplodon")
nodes <- unique(as.vector(cet_fit$call$tree$edge[edges,]))
Meso.x <- get.post.traits(cet_fit, select = nodes)
#or at everything EXCEPT Mesoplodon
notMeso.x <- get.post.traits(cet_fit, select = -nodes)
#you could also rely on string matching if you're interested in the tips only
Meso.tips.x <- get.post.traits(cet_fit, select = "Mesoplodon")

#could also look at quantiles, means, or diagnostics
med.x <- get.post.traits(cet_fit, select = nodes,
                     type = "quantiles",
                     extra.select = 0.5)
mean.x <- get.post.traits(cet_fit, select = nodes,
                          type = "means")
init.x <- get.post.traits(cet_fit, select = nodes,
                          type = "diagnostics",
                          extra.select = c("inits", "ess"))
                 
#here's an example of what happens when you don't simplify the result
med.x <- get.R(cet_fit, select = nodes,
               type = "quantiles",
               extra.select = 0.5,
               simplify = FALSE)
                 
#note that, depending on your goals, it may be more efficient to do things like this instead
x <- get.post.traits(cet_fit)
med.Meso.x <- x \%quantiles\% list(nodes, 0.5)


}
\seealso{
Other parameter extraction functions: 
\code{\link{get.R}()},
\code{\link{get.bg.rate}()},
\code{\link{remove.trend}()}
}
\concept{parameter extraction functions}
